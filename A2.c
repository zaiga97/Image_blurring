#include "mpi.h"
#include <stdio.h> 
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <omp.h>
#define _USE_MATH_DEFINES

#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif


  void swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 */
{
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      for ( int i = 0; i < size; i+= 1 )
  	((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 
  
  // Writing header
  // The header's format is as follows, all in ASCII.
  // "whitespace" is either a blank or a TAB or a CF or a LF
  // - The Magic Number (see below the magic numbers)
  // - the image's width
  // - the height
  // - a white space
  // - the image's height
  // - a whitespace
  // - the maximum color value, which must be between 0 and 65535
  //
  // if he maximum color value is in the range [0-255], then
  // a pixel will be expressed by a single byte; if the maximum is
  // larger than 255, then 2 bytes will be needed for each pixel
  //

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;

  /* ---------------------------------------------------------------

     TYPE    MAGIC NUM     EXTENSION   COLOR RANGE
           ASCII  BINARY

     PBM   P1     P4       .pbm        [0-1]
     PGM   P2     P5       .pgm        [0-255]
     PPM   P3     P6       .ppm        [0-2^16[
  
  ------------------------------------------------------------------ */
}

void read_pgm_image( short unsigned int **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
{

  FILE* image_file; 
  image_file = fopen(image_name, "r"); 


  *image = NULL;
  *xsize = *ysize = *maxval = 0;


  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );



  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );

  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}

void ker_init(const int type, const int k, double f, double* ker)
/*
* type 			: 0 for flat
* k 			: total dimension of the kernel, must be not even
* *ker      	: pointer to the future kernel
* *ker_weight 	: pointer to the future kernel weight
*/
{
	int dim = k*k;
	
	switch(type)
	{
 		case 0:																// Flat kernel 
	 		for (int i = 0; i < dim; ++i)
	 		{
	 			ker[i] = 1.0/(dim);
	 		}
 		break;

 		case 1:

 			if (k==1)
 			{
 				ker[0] = 1;
 				break;
 			}

 			for (int i = 0; i < dim; ++i)
	 		{
	 			ker[i] = (1 - f)/(dim - 1);
	 		}
	 		ker[((k-1)/2)*k + (k-1)/2] = f;
 		break;

 		case 2:

 			if (k==1)
 			{
 				ker[0] = 1;
 				break;
 			}

 			int s = (k-1)/2;
 			double semp = 1/(2*M_PI*s*s);
 			double sum = 0;

 			for (int i = 0; i < k; ++i)
 			{
 				for (int j = 0; j < k; ++j)
 				{
 					int x = (j-s);
 					int y = (i-s);
 					ker[j + i*k] = semp * exp(-((double)(x*x)+(y*y))/(2*s*s));
 					sum += ker[j + i*k];
 				}
 			}

 			for (int i = 0; i < k*k; ++i)
 			{
 				ker[i] = ker[i] / sum;
 			}

 		break;

 		default:
 			printf("Someting wrong in the selected kernel\n");
 		break;
	}
}

unsigned short int border_blur(const int xc, const int  yc, const int xsize, const int ysize, const int k, const double const ker[], const int ker_s, const unsigned short int const image[])
{
	int i_i, i_f, j_i, j_f;  // Set up the indicies over which perform the blur

	j_i = (xc - ker_s) < 0 ? -(xc - ker_s) : 0;
	j_f = (xc + ker_s) >= xsize ? k - (xc + ker_s - xsize + 1) : k;
	i_i = (yc - ker_s) < 0 ? -(yc - ker_s) : 0;
	i_f = (yc + ker_s) >= ysize ? k - (yc + ker_s - ysize + 1) : k;

	int inizio = (yc - (ker_s - i_i))*xsize + (xc - (ker_s - j_i));

	// printf("Punto:(%d,%d), Inizio:%d con indici i_i: %d, i_f: %d, j_i: %d, j_f: %d\n", xc,yc,inizio,i_i,i_f,j_i,j_f);

	double sum = 0;
	double renorm = 0;

	for (int i = i_i; i < i_f; ++i) //indice di riga (y)
	{
		for (int j = j_i; j < j_f; ++j) //indice di colonna (x)
		{
			sum += ker[(i*k + j)] * image[(inizio + ((i-i_i) * (xsize)) + j - j_i)];
			renorm += ker[(i*k + j)];
		}
	}

	sum = sum/renorm; // Correcting for luminosity
	return sum;
}


unsigned short int blur(const int xc, const int  yc, const int xsize, const int k, const double const ker[], const int ker_s, const unsigned short int const image[])
{
	int inizio = (yc - ker_s)*xsize + (xc - ker_s);
	double sum = 0;

	for (int i = 0; i < k; ++i) //indice di riga
	{
		for (int j = 0; j < k; ++j) //indice di colonna
		{
			sum += ker[(i*k + j)] * image[(inizio + (i * xsize) + j)];
		}
	}
	//printf("%d \n", (int)sum/ker_weight);
	return sum;
}

int main(int argc, char** argv)
{
	double start_time, end_time;
	//Inizialize MPI and create a grid

	start_time = MPI_Wtime();

	int numprocs, rank, dim[2], period[2], grid_pos[2];
	int reorder = 1;
	dim[0] = 0;
	dim[1] = 0;
	period[0] = 1;
	period[1] = 1;

	MPI_Init(&argc, &argv);
  	MPI_Comm_size(MPI_COMM_WORLD, &numprocs);
  	MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  	MPI_Dims_create(numprocs, 2, dim);

  	MPI_Comm GRID_COMM_WORLD;
  	MPI_Cart_create(MPI_COMM_WORLD, 2, dim, period, reorder, &GRID_COMM_WORLD);

  	MPI_Comm_size(GRID_COMM_WORLD, &numprocs);
  	MPI_Comm_rank(GRID_COMM_WORLD, &rank);



  	MPI_Cart_coords(GRID_COMM_WORLD, rank, 2, grid_pos);

	int ker_t, k; 
	double ker_f;
	char* image_name;
	char* output_name;

	// check inputs
	// kernel type, kernel dimension, kernel parameter
	// image to load, name of output
	if (argc < 4)
	{
		printf("Il numero di imput è sbagliato!! \n");
		printf("Exiting with error \n");
		return 1;
	}
	else
	{
		ker_t = atoi(argv[1]);
		k = atoi(argv[2]);

		if (ker_t == 1)
		{
			if (argc < 5)
			{
				printf("Il numero di imput è sbagliato!! \n");
				printf("Exiting with error \n");
				return 1;
			}
			ker_f =  atof(argv[3]);
			image_name = argv[4];
			if (argc > 5)
			{
				output_name = argv[5];
			}
			else
			{
				output_name = (char *)malloc(100 * sizeof(char));
        char *str = (char *)malloc(100 * sizeof(char));
        size_t len = strlen(image_name);
        for (int i = 0; i < len; ++i)
        {
          if (image_name[i] != '.')
          {
            str[i] = image_name[i];
          }
          else
          {
            str[i] = '\0';
          }
        }
				sprintf(output_name, "%s.b_%d_%dx%d_%3f.pgm",str, ker_t, k, k, ker_f);
			}
		}

		else
		{
			image_name = argv[3];
			if (argc > 4)
			{
				output_name = argv[5];
			}
			else
			{
				output_name = (char *)malloc(100 * sizeof(char));
				char *str = (char *)malloc(100 * sizeof(char));
				size_t len = strlen(image_name);
				for (int i = 0; i < len; ++i)
        {
          if (image_name[i] != '.')
          {
            str[i] = image_name[i];
          }
          else
          {
            str[i] = '\0';
          }
        }
				sprintf(output_name, "%s.b_%d_%dx%d.pgm",str, ker_t, k, k);
			}
		}
	}

	unsigned int ker_s = (k-1)/2;

  int xsize, ysize, maxval;
	unsigned short int *image;
	unsigned short int *blurred_img;

	unsigned int size;

  	if (rank == 0) // Read the image 
  	{
		read_pgm_image(&image, &maxval, &xsize, &ysize, image_name);
		if ( I_M_LITTLE_ENDIAN ) swap_image( image, xsize, ysize, maxval);
		//printf("maxval :%d xsize:%d ysize:%d\n", maxval, xsize, ysize);

		size = xsize * ysize * (1 + ( maxval > 255 ));
		blurred_img = (unsigned short int*)malloc( size * sizeof(char));
  	}

  	MPI_Bcast(&xsize, 1, MPI_INT, 0, GRID_COMM_WORLD);
  	MPI_Bcast(&ysize, 1, MPI_INT, 0, GRID_COMM_WORLD);
  	MPI_Bcast(&size, 1, MPI_UNSIGNED, 0, GRID_COMM_WORLD);

  	MPI_Barrier(GRID_COMM_WORLD);

  	// Inizialize sub images dimensions
  	
  	if (rank != 0)
  	{
  		image = (unsigned short int*)malloc( size * sizeof(char));
  	}

  	int npcol = dim[0];
  	int nprow = dim[1];
  	int blockrows = ysize/nprow;
  	int blockcols = xsize/npcol;


  	// Define sub blocks datastructures
  	MPI_Datatype blocktype;
  	MPI_Datatype blocktype2;
    MPI_Type_vector(blockrows, blockcols, xsize, MPI_UNSIGNED_SHORT, &blocktype2);
    MPI_Type_create_resized( blocktype2, 0, sizeof(unsigned short int), &blocktype);
    MPI_Type_commit(&blocktype);

    // Define the parameters for gathering 
	 int disps[nprow*npcol];
    int counts[nprow*npcol];
    for (int ii=0; ii<nprow; ii++) {
        for (int jj=0; jj<npcol; jj++) {
            disps[ii*npcol+jj] = ii*xsize*blockrows+jj*blockcols;
            counts [ii*npcol+jj] = 1;
        }
    }

 	//printf("Dimensions: (%d,%d) \n", dim[0], dim[1]);


// inizialize right kernel

	double *ker = (double *)malloc(k * k * sizeof(double));
	ker_init(ker_t, k, ker_f, ker);

	// print debug information
	/*
	printf("Kernel: \n");
	double sum = 0;
	for (int i = 0; i < k*k; ++i)
	{
		if (i%(k) == 0 && i != 0)
		{
			printf("\n");
		}
		printf("%f ", ker[i]);
		sum += ker[i];
	}
	printf("\n");
	printf("Kernel weight: %f\n\n", sum);
	*/

	MPI_Bcast(image, xsize*ysize, MPI_UNSIGNED_SHORT, 0, GRID_COMM_WORLD);
	short unsigned int* local_blurred_image;
	local_blurred_image = (short unsigned int *)malloc(blockcols * blockrows * sizeof(short int));

	MPI_Barrier(GRID_COMM_WORLD);

	int x_init = (rank % dim[0]) * blockcols;
	int y_init = (rank / dim[0]) * blockrows;

	//printf("Hi before the blur i'm process #: %d of %d, My coord are:(%d,%d)\nI start from: %d, %d and end in: %d, %d\n\n",rank, numprocs, grid_pos[0], grid_pos[1], x_init, y_init,  x_init + blockcols, y_init + blockrows);
	
	#pragma omp parallel //proc_bind( master )  //Perform the blur only of the small block
		{
			#pragma omp for
			for (int j = y_init; j < y_init + blockrows; ++j)
			{
				for (int i = x_init; i < x_init + blockcols; ++i)
				{
					if ((j < ker_s) || (j >= ysize - ker_s) || (i < ker_s) || (i >= xsize - ker_s))
					{
						local_blurred_image[((j - y_init) * blockcols) + i - x_init] = border_blur(i, j, xsize, ysize, k, ker, ker_s, image);
					}
					else
					{
						local_blurred_image[((j - y_init) * blockcols) + i - x_init] = blur(i, j, xsize, k, ker, ker_s, image);
					}			
				}
			}
		}
	
	// Gather the blocks in the blurred image
	MPI_Gatherv(local_blurred_image, blockrows * blockcols, MPI_UNSIGNED_SHORT, blurred_img, counts, disps, blocktype, 0, GRID_COMM_WORLD);


	if (rank == 0)		// Processing the remaining of the image
	{
		#pragma omp parallel //proc_bind( master )   //Perform the blur only of the small block
		{
			#pragma omp for
			for (int j = 0; j < ysize; ++j)
			{
				for (int i = dim[0]*blockcols; i < xsize; ++i)
				{
						if ((j < ker_s) || (j >= ysize - ker_s) || (i < ker_s) || (i >= xsize - ker_s))
						{
							blurred_img[(j * xsize) + i] = border_blur(i, j, xsize, ysize, k, ker, ker_s, image);
						}
						else
						{
							blurred_img[(j * xsize) + i] = blur(i, j, xsize, k, ker, ker_s, image);
						}	
				}
			}
			#pragma omp for
			for (int j = dim[1]*blockrows; j < ysize; ++j)
			{
				for (int i = 0; i < xsize; ++i)
				{
						if ((j < ker_s) || (j >= ysize - ker_s) || (i < ker_s) || (i >= xsize - ker_s))
						{
							blurred_img[(j * xsize) + i] = border_blur(i, j, xsize, ysize, k, ker, ker_s, image);
						}
						else
						{
							blurred_img[(j * xsize) + i] = blur(i, j, xsize, k, ker, ker_s, image);
						}	
				}
			}
		}
	}

	if (rank == 0)		// Write the result
	{
		if ( I_M_LITTLE_ENDIAN ) swap_image( blurred_img, xsize, ysize, maxval);
		write_pgm_image(blurred_img, 65535, xsize, ysize, output_name);
		//printf("Writing the result in %s \n", output_name);
		end_time = MPI_Wtime();
		printf("%d, %f\n", numprocs, end_time - start_time);
	}

	// be aware of real borders

// send back from nodes to main node

// output
	MPI_Barrier(GRID_COMM_WORLD);
	MPI_Finalize();

	return 0;
}
